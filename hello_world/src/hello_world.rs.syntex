pub fn hello_world() -> u8 {
    my_syntax!()
}

/*
//////////////////////////////////////////////////////////////////////////////

pub mod foo {
    pub type I = i32;
}

#[derive(Copy, PartialEq)]
struct Peekable<I> where I: Iterator {
    iter: I,
    next: Option<<I as Iterator>::Item>,
}

#[derive(Copy, PartialEq)]
enum Peekable2<I> where I: Iterator {
    Unit,
    Seq(
        //foo::I,
        <I as Iterator>::Item,
    ),
    Map {
        //a: foo::I,
        b: <I as Iterator>::Item,
    }
}
*/


//////////////////////////////////////////////////////////////////////////////



// Copyright 2015 The Rust Project Developers. See the COPYRIGHT
// file at the top-level directory of this distribution and at
// http://rust-lang.org/COPYRIGHT.
//
// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or
// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license
// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your
// option. This file may not be copied, modified, or distributed
// except according to those terms.

trait DeclaredTrait {
    type Type;
}

impl DeclaredTrait for i32 {
    type Type = i32;
}

trait WhereTrait {
    type Type;
}

impl WhereTrait for i32 {
    type Type = i32;
}

// Make sure we don't add a bound that just shares a name with an associated
// type.
pub mod module {
    pub type Type = i32;
}

#[derive(PartialEq, Show)]
pub struct Struct<A, B: DeclaredTrait, C> where C: WhereTrait {
    m1: module::Type,
    m2: Option<module::Type>,
    a: A,
    b: B,
    b1: B::Type,
    b2: Option<B::Type>,
    b3: <B as DeclaredTrait>::Type,
    b4: Option<<B as DeclaredTrait>::Type>,
    c: C,
    // FIXME(#20300)
    //c1: C::Type,
    //c2: Option<<C as DeclaredTrait>::Type>,
    c3: <C as WhereTrait>::Type,
    c4: Option<<C as WhereTrait>::Type>,
}

/*
#[derive(PartialEq, Show)]
enum Enum<A, B: DeclaredTrait, C> where C: WhereTrait {
    Unit,
    Seq(
        module::Type,
        Option<module::Type>,
        A,
        B,
        B::Type,
        Option<B::Type>,
        <B as DeclaredTrait>::Type,
        Option<<B as DeclaredTrait>::Type>,
        C,
        // FIXME(#20300)
        //C::Type,
        //Option<C::Type>,
        <C as WhereTrait>::Type,
        Option<<C as WhereTrait>::Type>,
    ),
    Map {
        m1: module::Type,
        m2: Option<module::Type>,
        a: A,
        b: B,
        b1: B::Type,
        b2: Option<B::Type>,
        b3: <B as DeclaredTrait>::Type,
        b4: Option<<B as DeclaredTrait>::Type>,
        c: C,
        // FIXME(#20300)
        //c1: C::Type,
        //c2: Option<C::Type>,
        c3: <C as WhereTrait>::Type,
        c4: Option<<C as WhereTrait>::Type>,
    },
}

fn main() {
    let e = Struct {
        m1: 0,
        m2: 0,
        a: 0,
        b: 0,
        b1: 0,
        b2: 0,
        b3: 0,
        b4: None,
        c: 0,
        // FIXME(#20300)
        //c1: 0,
        //c2: 0,
        c3: 0,
        c4: None,
    };
    e == e;
    //assert_eq!(v, v);

    /*
    let e = Enum::Unit::<i32, i32, i32>;
    e == e;
    //assert_eq!(e, e);

    let e = Enum::Seq(
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        None,
        0,
        // FIXME(#20300)
        //0,
        //0,
        0,
        None,
    );
    e == e;
    //assert_eq!(e, e);

    let e = Enum::Map {
        m1: 0,
        m2: 0,
        a: 0,
        b: 0,
        b1: 0,
        b2: 0,
        b3: 0,
        b4: None,
        c: 0,
        // FIXME(#20300)
        //c1: 0,
        //c2: 0,
        c3: 0,
        c4: None,
    };
    e == e;
    //assert_eq!(e, e);
    */
}
*/
